# -*- coding: utf-8 -*-
"""Long Sequences CDS Detection using SSA + WOA.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1vBWIgRpvLy9X6aeOrK_qa7NbGBxm4AQf
"""

!pip install biopython

import math
import time
import random
import numpy as np
from scipy import signal
from statistics import mean
from Bio import SeqIO, Entrez
from sklearn.metrics import auc
import matplotlib.pyplot as plt

desiredFilter_w, desiredFilter_h = np.arange(0, 1, 0.001, dtype = float), np.zeros(1000, dtype=float)
desiredFilter_h[667] = 1

fig_1, ax = plt.subplots(figsize = [12.8, 7.2], dpi = 100)
plt.title('Ideal Period-3 Impulse Response', fontsize=15, pad=12)
plt.xlabel('Normalized Frequency $(w / \pi)$', fontsize=12, labelpad=5)
plt.ylabel('Magnitude Response', fontsize=12, labelpad=5)
plt.plot(desiredFilter_w, desiredFilter_h, color='r')
#fig_1.savefig('test_1.jpg')

# Objective Function 2
def objf(currentFilterPosition):
    w, h = signal.freqz(currentFilterPosition, a = 1, worN = 1000, whole = False)
    h = np.array(h)
    h1 = abs(h)
    Ep = (1 - h1[667]) ** 2
    Es = np.sum(h1[0:666]) ** 2 + np.sum(h1[668:1000]) ** 2
    error = 100 * Ep + 0.01 * Es
    return error

def SSAWOA(objf, lb, ub, dim, N, Max_iteration):

    if not isinstance(lb, list):
        lb = [lb] * dim
    if not isinstance(ub, list):
        ub = [ub] * dim

    Convergence_curve = np.zeros(Max_iteration)

    # Initialize the positions of salps
    SalpPositions = np.zeros((N, dim))
    for i in range(dim):
        SalpPositions[:, i] = np.random.uniform(0, 1, N) * (ub[i] - lb[i]) + lb[i]
    SalpFitness = np.full(N, float("inf"))

    FoodPosition = np.zeros(dim)
    FoodFitness = float("inf")

    for i in range(0, N):
        # evaluate moths
        SalpFitness[i] = objf(SalpPositions[i, :])

    sorted_salps_fitness = np.sort(SalpFitness)
    I = np.argsort(SalpFitness)

    Sorted_salps = np.copy(SalpPositions[I, :])

    FoodPosition = np.copy(Sorted_salps[0, :])
    FoodFitness = sorted_salps_fitness[0]

    # initialize position vector and score for the leader
    Leader_pos = np.zeros(dim)
    Leader_score = float("inf")  # change this to -inf for maximization problems

    # Initialize the positions of search agents
    Positions = np.zeros((N, dim))
    for i in range(dim):
        Positions[:, i] = np.random.uniform(0, 1, N) * (ub[i] - lb[i]) + lb[i]

    fitness = np.full(N, float("inf"))
    # calculate fitness for all the population
    for i in range(N):
        particle_fitness = objf(Positions[i, :])
        fitness[i] = particle_fitness

        if particle_fitness < Leader_score:
            Leader_score = particle_fitness
            Leader_pos = Positions[i, :]

    Iteration = 1
    timerStart = time.time()

    # Main loop
    while Iteration < Max_iteration:

        # Number of flames Eq. (3.14) in the paper
        # Flame_no=round(N-Iteration*((N-1)/Max_iteration));

        c1 = 2 * math.exp(-((4 * Iteration / Max_iteration) ** 2))
        # Eq. (3.2) in the paper

        for i in range(0, N):

            SalpPositions = np.transpose(SalpPositions)

            if i < N / 2:
                for j in range(0, dim):
                    c2 = random.random()
                    c3 = random.random()
                    # Eq. (3.1) in the paper
                    if c3 < 0.5:
                        SalpPositions[j, i] = FoodPosition[j] + c1 * (
                            (ub[j] - lb[j]) * c2 + lb[j]
                        )
                    else:
                        SalpPositions[j, i] = FoodPosition[j] - c1 * (
                            (ub[j] - lb[j]) * c2 + lb[j]
                        )

                    ####################

            elif i >= N / 2 and i < N + 1:
                point1 = SalpPositions[:, i - 1]
                point2 = SalpPositions[:, i]

                SalpPositions[:, i] = (point2 + point1) / 2
                # Eq. (3.4) in the paper

            SalpPositions = np.transpose(SalpPositions)

        a = 2 - Iteration * ((2) / Max_iteration)
        # a decreases linearly fron 2 to 0 in Eq. (2.3)

        # a2 linearly decreases from -1 to -2 to calculate t in Eq. (3.12)
        a2 = -1 + Iteration * ((-1) / Max_iteration)

        # Update the Position of search agents
        for i in range(0, N):
            r1 = random.random()  # r1 is a random number in [0,1]
            r2 = random.random()  # r2 is a random number in [0,1]

            A = 2 * a * r1 - a  # Eq. (2.3) in the paper
            C = 2 * r2  # Eq. (2.4) in the paper

            b = 1
            #  parameters in Eq. (2.5)
            l = (a2 - 1) * random.random() + 1  #  parameters in Eq. (2.5)

            p = random.random()  # p in Eq. (2.6)

            for j in range(0, dim):

                if p < 0.5:
                    if abs(A) >= 1:
                        rand_leader_index = math.floor(
                            N * random.random()
                        )
                        X_rand = Positions[rand_leader_index, :]
                        D_X_rand = abs(C * X_rand[j] - Positions[i, j])
                        Positions[i, j] = X_rand[j] - A * D_X_rand

                    elif abs(A) < 1:
                        D_Leader = abs(C * Leader_pos[j] - Positions[i, j])
                        Positions[i, j] = Leader_pos[j] - A * D_Leader

                elif p >= 0.5:

                    distance2Leader = abs(Leader_pos[j] - Positions[i, j])
                    # Eq. (2.5)
                    Positions[i, j] = (
                        distance2Leader * math.exp(b * l) * math.cos(l * 2 * math.pi)
                        + Leader_pos[j]
                    )

        for i in range(0, N):

            # Check if salps go out of the search spaceand bring it back
            for j in range(dim):
                SalpPositions[i, j] = np.clip(SalpPositions[i, j], lb[j], ub[j])
                Positions[i, j] = np.clip(Positions[i, j], lb[j], ub[j])

            SalpFitness[i] = objf(SalpPositions[i, :])
            fitness[i] = objf(Positions[i, :])

            if SalpFitness[i] < fitness[i]:
                Positions[i, :] = np.copy(SalpPositions[i, :])
                fitness[i] = SalpFitness[i]

                if SalpFitness[i] < FoodFitness:
                    FoodPosition = np.copy(SalpPositions[i, :])
                    FoodFitness = SalpFitness[i]

            if fitness[i] < SalpFitness[i]:
                SalpPositions[i, :] = np.copy(Positions[i, :])
                SalpFitness[i] = fitness[i]

                # Update the leader
                if fitness[i] < Leader_score:  # Change this to > for maximization problem
                    Leader_score = fitness[i]
                    Leader_pos = Positions[i, :].copy()  # copy current whale position into the leader position

        # Display best fitness along the iteration
        if (Iteration + 1) % 100 == 0:
            print(["At iteration " + str(Iteration + 1) + " the best fitness is " + str(Leader_score)])

        Convergence_curve[Iteration] = Leader_score
        Iteration = Iteration + 1

    timerEnd = time.time()
    timer = timerEnd - timerStart
    print(["Food Fitness is: " + str(FoodFitness)] )
    print(["Leader Score is: "+ str(Leader_score)])
    return Leader_pos, Convergence_curve, timer # instead of returning Leader_pos everytime, compare Leader_score and FoodFitness and return the smaller one. Althogh the result is not improving much but it is in accordance with written algorithm.

#SSAWOA Format :- SSAWOA(Objective Function, Lower Boundary, Upper Boundary, Dimension, Population Size, Iterations)
Filter_weights, Optimization_error, Execution_time = SSAWOA(objf, -1, 1, 250, 50, 2500)

temp_x, temp_y = signal.freqz(Filter_weights, a = 1, worN = 1000, whole = False)

fig_2, ax = plt.subplots(figsize = [12.8, 7.2], dpi = 100)
plt.title('FIR Filter Response on Ideal Period-3 Impulse using SSA + WOA', fontsize=15, pad=12)
plt.xlabel('Normalized Frequency $(w / \pi)$', fontsize=12, labelpad=5)
plt.ylabel('Magnitude Response', fontsize=12, labelpad=5)
#plt.plot(temp_x / np.pi, 20 * np.log10(abs(temp_y)), color='b')
plt.plot(desiredFilter_w, desiredFilter_h, color='r')
plt.plot(temp_x / np.pi, abs(temp_y), color='b')
#fig_2.savefig('test_2.jpg')

def cds_calculation(cds):
    cds_1, cds_2 = [], []
    for i in range(len(cds)):
        if i % 2 == 0:
            cds_1.append(int((cds[i]-1)))
        else:
            cds_2.append(int((cds[i])))
    cds = []
    for i in range(len(cds_1)):
        cds = cds + (list(range(cds_1[i], cds_2[i])))
    return cds

def non_cds_calculation(ncds):
    ncds_1, ncds_2 = [], []
    for i in range(len(ncds)):
        if i % 2 == 1:
            ncds_1.append(int((ncds[i]-1)))
        else:
            ncds_2.append(int((ncds[i])))
    ncds = []
    for i in range(len(ncds_1)):
        ncds = ncds + (list(range(ncds_2[i], ncds_1[i])))
    return ncds

def voss_mapping(dna_sequence):
    xA, xT, xC, xG = np.zeros(len(dna_sequence)), np.zeros(len(dna_sequence)), np.zeros(len(dna_sequence)), np.zeros(len(dna_sequence))
    for i in range(len(dna_sequence)):
        if dna_sequence[i] == 'A':
            xA[i], xT[i], xC[i], xG[i] = 1, 0, 0, 0
        elif dna_sequence[i] == 'T':
            xA[i], xT[i], xC[i], xG[i] = 0, 1, 0, 0
        elif dna_sequence[i] == 'C':
            xA[i], xT[i], xC[i], xG[i] = 0, 0, 1, 0
        elif dna_sequence[i] == 'G':
            xA[i], xT[i], xC[i], xG[i] = 0, 0, 0, 1
    return xA, xT, xC, xG

def sequence_download(id_number):
    Entrez.email = "Your.Name.Here@example.org"
    handle = Entrez.efetch(db = 'nucleotide', id = id_number, rettype = 'fasta', retmode = 'text')
    record = SeqIO.read(handle, 'fasta')
    originial_sequence = record.seq
    return originial_sequence

def exons_predictions(filter_weights, xA, xT, xC, xG):
    polyorder, window_length = 7, 87
    u_A, u_T = signal.filtfilt(filter_weights, 1, xA, padlen = 50), signal.filtfilt(filter_weights, 1, xT, padlen = 50) 
    u_C, u_G = signal.filtfilt(filter_weights, 1, xC, padlen = 50), signal.filtfilt(filter_weights, 1, xG, padlen = 50)
    Y_A, Y_T, Y_C, Y_G = abs(u_A) ** 2, abs(u_T) ** 2, abs(u_C) ** 2, abs(u_G) ** 2
    Z_A, Z_T = signal.savgol_filter(Y_A, window_length, polyorder), signal.savgol_filter(Y_T, window_length, polyorder)
    Z_C, Z_G = signal.savgol_filter(Y_C, window_length, polyorder), signal.savgol_filter(Y_G, window_length, polyorder)
    P = Z_A + Z_T + Z_C + Z_G
    P = P / max(P)
    return P

def binary_classification(cds, ncds, P, sample_dna):
  
    Threshold_Values = np.linspace(0, 1, num=101, endpoint = True)
    TP_Values, FN_Values = np.zeros(len(Threshold_Values)), np.zeros(len(Threshold_Values))
    FP_Values, TN_Values = np.zeros(len(Threshold_Values)), np.zeros(len(Threshold_Values))

    for k in range(len(Threshold_Values)):
        TP, FN, FP, TN, Threshold = np.zeros(len(sample_dna)), np.zeros(len(sample_dna)), np.zeros(len(sample_dna)), np.zeros(len(sample_dna)), Threshold_Values[k]
        for i in cds:
            if (P[i] >= Threshold):
                TP[i] = 1
            if (P[i] < Threshold):
                FN[i] = 1
        for i in ncds:
            if (P[i] >= Threshold):
                FP[i] = 1
            if (P[i] < Threshold):
                TN[i] = 1
        TP_Values[k], FN_Values[k], FP_Values[k], TN_Values[k] = np.sum(TP), np.sum(FN), np.sum(FP), np.sum(TN)

    return TP_Values, FN_Values, FP_Values, TN_Values

sequence_id = "NG_042044"
region_values = [5053, 5188, 12934, 13085, 50691, 50822, 94645, 94875]

sequence = sequence_download(sequence_id)

coding_regions = region_values
non_coding_regions = [0] + coding_regions + [len(sequence) + 1]
coding_regions, non_coding_regions = cds_calculation(coding_regions), non_cds_calculation(non_coding_regions)

actual_exons = np.zeros(len(sequence))
for i in coding_regions:
    actual_exons[i] = 1

mapped_A, mapped_T, mapped_C, mapped_G = voss_mapping(sequence)
predicted_exons = exons_predictions(Filter_weights, mapped_A, mapped_T, mapped_C, mapped_G)

true_positive, false_negative, false_positive, true_negative = binary_classification(coding_regions, non_coding_regions, predicted_exons, sequence)
TP, FN, FP, TN = true_positive[20], false_negative[20], false_positive[20], true_negative[20]

TPR, TNR, PPV, ACC = TP / (TP + FN), TN / (FP + TN), TP / (TP + FP), (TP + TN) / (TP + FP + TN + FN)
MCC = (TP * TN - FN * FP) / (((TP + FN) * (TN + FP) * (TP + FP) * (TN + FN)) ** (1/2))
ACP = (TP / (TP + FN) + TP / (TP + FP) + TN / (TN + FP) + TN / (TN + FN)) / 4
AC = (ACP - 0.5) * 2

exon_energy, intron_energy = [], []
for i in coding_regions:
    exon_energy.append(predicted_exons[i])
for i in non_coding_regions:
    intron_energy.append(predicted_exons[i])

SNR1, SNR2 = sum(exon_energy)/sum(intron_energy), max(predicted_exons) / mean(predicted_exons)

print('SNR1 =', SNR1)
print('SNR2 =', SNR2)
print("Approximate Correlation =", AC)
print('Accuracy of Exon Classification =', ACC)
print('True Positive Rate (Sensitiviy) =', TPR)
print('True Negative Rate (Specificity) =', TNR)
print('Matthews Correlation Coefficient = ', MCC), 
print('Positive Predictive Value (Precision) =',PPV)

TPR_Values, FPR_Values = np.zeros(101), np.zeros(101)

for k in range(101):
    TPR_Values[k] = true_positive[k] / (true_positive[k] + false_negative[k])
    FPR_Values[k] = false_positive[k] / (false_positive[k] + true_negative[k])

auc_value = auc(FPR_Values, TPR_Values)
print('Area Under The ROC Curve =', auc_value)

fig_3, ax = plt.subplots(figsize = [12.8, 7.2], dpi = 100)
plt.title('Detection of Exon region of Gene NG_042044 Using SSA + WOA', fontsize=15, pad=12)
plt.ylabel('Normalised Period-3 Power spectrum', fontsize=12, labelpad=5)
plt.xlabel('Relative Base location (bp)', fontsize = 12, labelpad = 5)
plt.plot(np.full(8000, 0.2), alpha = 0.5, linewidth = 0.5, color='r')
plt.plot(predicted_exons, linewidth=1, color='b')
plt.plot(actual_exons, color='g')

sequence_id = "AJ289156"
region_values = [91, 163, 294, 563, 805, 1080]

sequence = sequence_download(sequence_id)

coding_regions = region_values
non_coding_regions = [0] + coding_regions + [len(sequence) + 1]
coding_regions, non_coding_regions = cds_calculation(coding_regions), non_cds_calculation(non_coding_regions)

actual_exons = np.zeros(len(sequence))
for i in coding_regions:
    actual_exons[i] = 1

mapped_A, mapped_T, mapped_C, mapped_G = voss_mapping(sequence)
predicted_exons = exons_predictions(Filter_weights, mapped_A, mapped_T, mapped_C, mapped_G)

true_positive, false_negative, false_positive, true_negative = binary_classification(coding_regions, non_coding_regions, predicted_exons, sequence)
TP, FN, FP, TN = true_positive[20], false_negative[20], false_positive[20], true_negative[20]

TPR, TNR, PPV, ACC = TP / (TP + FN), TN / (FP + TN), TP / (TP + FP), (TP + TN) / (TP + FP + TN + FN)
MCC = (TP * TN - FN * FP) / (((TP + FN) * (TN + FP) * (TP + FP) * (TN + FN)) ** (1/2))
ACP = (TP / (TP + FN) + TP / (TP + FP) + TN / (TN + FP) + TN / (TN + FN)) / 4
AC = (ACP - 0.5) * 2

exon_energy, intron_energy = [], []
for i in coding_regions:
    exon_energy.append(predicted_exons[i])
for i in non_coding_regions:
    intron_energy.append(predicted_exons[i])

SNR1, SNR2 = sum(exon_energy)/sum(intron_energy), max(predicted_exons) / mean(predicted_exons)

print('SNR1 =', SNR1)
print('SNR2 =', SNR2)
print("Approximate Correlation =", AC)
print('Accuracy of Exon Classification =', ACC)
print('True Positive Rate (Sensitiviy) =', TPR)
print('True Negative Rate (Specificity) =', TNR)
print('Matthews Correlation Coefficient = ', MCC), 
print('Positive Predictive Value (Precision) =',PPV)

TPR_Values, FPR_Values = np.zeros(101), np.zeros(101)

for k in range(101):
    TPR_Values[k] = true_positive[k] / (true_positive[k] + false_negative[k])
    FPR_Values[k] = false_positive[k] / (false_positive[k] + true_negative[k])

auc_value = auc(FPR_Values, TPR_Values)
print('Area Under The ROC Curve =', auc_value)

fig_4, ax = plt.subplots(figsize = [12.8, 7.2], dpi = 100)
plt.title('Detection of Exon region of Gene NG_007071 Using SSA + WOA', fontsize=15, pad=12)
plt.ylabel('Normalised Period-3 Power spectrum', fontsize=12, labelpad=5)
plt.xlabel('Relative Base location (bp)', fontsize = 12, labelpad = 5)
plt.plot(np.full(8000, 0.2), alpha = 0.5, linewidth = 0.5, color='r')
plt.plot(predicted_exons, linewidth=1, color='b')
plt.plot(actual_exons, color='g')

sequence_id = "M19160"
region_values = [1,67,164,280,393,428]

sequence = sequence_download(sequence_id)

coding_regions = region_values
non_coding_regions = [0] + coding_regions + [len(sequence) + 1]
coding_regions, non_coding_regions = cds_calculation(coding_regions), non_cds_calculation(non_coding_regions)

actual_exons = np.zeros(len(sequence))
for i in coding_regions:
    actual_exons[i] = 1

mapped_A, mapped_T, mapped_C, mapped_G = voss_mapping(sequence)
predicted_exons = exons_predictions(Filter_weights, mapped_A, mapped_T, mapped_C, mapped_G)

true_positive, false_negative, false_positive, true_negative = binary_classification(coding_regions, non_coding_regions, predicted_exons, sequence)
TP, FN, FP, TN = true_positive[20], false_negative[20], false_positive[20], true_negative[20]

TPR, TNR, PPV, ACC = TP / (TP + FN), TN / (FP + TN), TP / (TP + FP), (TP + TN) / (TP + FP + TN + FN)
MCC = (TP * TN - FN * FP) / (((TP + FN) * (TN + FP) * (TP + FP) * (TN + FN)) ** (1/2))
ACP = (TP / (TP + FN) + TP / (TP + FP) + TN / (TN + FP) + TN / (TN + FN)) / 4
AC = (ACP - 0.5) * 2

exon_energy, intron_energy = [], []
for i in coding_regions:
    exon_energy.append(predicted_exons[i])
for i in non_coding_regions:
    intron_energy.append(predicted_exons[i])

SNR1, SNR2 = sum(exon_energy)/sum(intron_energy), max(predicted_exons) / mean(predicted_exons)

print('SNR1 =', SNR1)
print('SNR2 =', SNR2)
print("Approximate Correlation =", AC)
print('Accuracy of Exon Classification =', ACC)
print('True Positive Rate (Sensitiviy) =', TPR)
print('True Negative Rate (Specificity) =', TNR)
print('Matthews Correlation Coefficient = ', MCC), 
print('Positive Predictive Value (Precision) =',PPV)

TPR_Values, FPR_Values = np.zeros(101), np.zeros(101)

for k in range(101):
    TPR_Values[k] = true_positive[k] / (true_positive[k] + false_negative[k])
    FPR_Values[k] = false_positive[k] / (false_positive[k] + true_negative[k])

auc_value = auc(FPR_Values, TPR_Values)
print('Area Under The ROC Curve =', auc_value)

fig_5, ax = plt.subplots(figsize = [12.8, 7.2], dpi = 100)
plt.title('Detection of Exon region of Gene NG_029760 Using SSA + WOA', fontsize=15, pad=12)
plt.ylabel('Normalised Period-3 Power spectrum', fontsize=12, labelpad=5)
plt.xlabel('Relative Base location (bp)', fontsize = 12, labelpad = 5)
plt.plot(np.full(8000, 0.2), alpha = 0.5, linewidth = 0.5, color='r')
plt.plot(predicted_exons, linewidth=1, color='b')
plt.plot(actual_exons, color='g')

sequence_id = "U03291"
region_values = [17, 427]

sequence = sequence_download(sequence_id)

coding_regions = region_values
non_coding_regions = [0] + coding_regions + [len(sequence) + 1]
coding_regions, non_coding_regions = cds_calculation(coding_regions), non_cds_calculation(non_coding_regions)

actual_exons = np.zeros(len(sequence))
for i in coding_regions:
    actual_exons[i] = 1

mapped_A, mapped_T, mapped_C, mapped_G = voss_mapping(sequence)
predicted_exons = exons_predictions(Filter_weights, mapped_A, mapped_T, mapped_C, mapped_G)

true_positive, false_negative, false_positive, true_negative = binary_classification(coding_regions, non_coding_regions, predicted_exons, sequence)
TP, FN, FP, TN = true_positive[20], false_negative[20], false_positive[20], true_negative[20]

TPR, TNR, PPV, ACC = TP / (TP + FN), TN / (FP + TN), TP / (TP + FP), (TP + TN) / (TP + FP + TN + FN)
MCC = (TP * TN - FN * FP) / (((TP + FN) * (TN + FP) * (TP + FP) * (TN + FN)) ** (1/2))
ACP = (TP / (TP + FN) + TP / (TP + FP) + TN / (TN + FP) + TN / (TN + FN)) / 4
AC = (ACP - 0.5) * 2

exon_energy, intron_energy = [], []
for i in coding_regions:
    exon_energy.append(predicted_exons[i])
for i in non_coding_regions:
    intron_energy.append(predicted_exons[i])

SNR1, SNR2 = sum(exon_energy)/sum(intron_energy), max(predicted_exons) / mean(predicted_exons)

print('SNR1 =', SNR1)
print('SNR2 =', SNR2)
print("Approximate Correlation =", AC)
print('Accuracy of Exon Classification =', ACC)
print('True Positive Rate (Sensitiviy) =', TPR)
print('True Negative Rate (Specificity) =', TNR)
print('Matthews Correlation Coefficient = ', MCC), 
print('Positive Predictive Value (Precision) =',PPV)

TPR_Values, FPR_Values = np.zeros(101), np.zeros(101)

for k in range(101):
    TPR_Values[k] = true_positive[k] / (true_positive[k] + false_negative[k])
    FPR_Values[k] = false_positive[k] / (false_positive[k] + true_negative[k])

auc_value = auc(FPR_Values, TPR_Values)
print('Area Under The ROC Curve =', auc_value)

fig_6, ax = plt.subplots(figsize = [12.8, 7.2], dpi = 100)
plt.title('Detection of Exon region of Gene NG_050658 Using SSA + WOA', fontsize=15, pad=12)
plt.ylabel('Normalised Period-3 Power spectrum', fontsize=12, labelpad=5)
plt.xlabel('Relative Base location (bp)', fontsize = 12, labelpad = 5)
plt.plot(np.full(8000, 0.2), alpha = 0.5, linewidth = 0.5, color='r')
plt.plot(predicted_exons, linewidth=1, color='b')
plt.plot(actual_exons, color='g')

sequence_id = "U20223"
region_values = [180, 271, 402, 438]

sequence = sequence_download(sequence_id)

coding_regions = region_values
non_coding_regions = [0] + coding_regions + [len(sequence) + 1]
coding_regions, non_coding_regions = cds_calculation(coding_regions), non_cds_calculation(non_coding_regions)

actual_exons = np.zeros(len(sequence))
for i in coding_regions:
    actual_exons[i] = 1

mapped_A, mapped_T, mapped_C, mapped_G = voss_mapping(sequence)
predicted_exons = exons_predictions(Filter_weights, mapped_A, mapped_T, mapped_C, mapped_G)

true_positive, false_negative, false_positive, true_negative = binary_classification(coding_regions, non_coding_regions, predicted_exons, sequence)
TP, FN, FP, TN = true_positive[20], false_negative[20], false_positive[20], true_negative[20]

TPR, TNR, PPV, ACC = TP / (TP + FN), TN / (FP + TN), TP / (TP + FP), (TP + TN) / (TP + FP + TN + FN)
MCC = (TP * TN - FN * FP) / (((TP + FN) * (TN + FP) * (TP + FP) * (TN + FN)) ** (1/2))
ACP = (TP / (TP + FN) + TP / (TP + FP) + TN / (TN + FP) + TN / (TN + FN)) / 4
AC = (ACP - 0.5) * 2

exon_energy, intron_energy = [], []
for i in coding_regions:
    exon_energy.append(predicted_exons[i])
for i in non_coding_regions:
    intron_energy.append(predicted_exons[i])

SNR1, SNR2 = sum(exon_energy)/sum(intron_energy), max(predicted_exons) / mean(predicted_exons)

print('SNR1 =', SNR1)
print('SNR2 =', SNR2)
print("Approximate Correlation =", AC)
print('Accuracy of Exon Classification =', ACC)
print('True Positive Rate (Sensitiviy) =', TPR)
print('True Negative Rate (Specificity) =', TNR)
print('Matthews Correlation Coefficient = ', MCC), 
print('Positive Predictive Value (Precision) =',PPV)

TPR_Values, FPR_Values = np.zeros(101), np.zeros(101)

for k in range(101):
    TPR_Values[k] = true_positive[k] / (true_positive[k] + false_negative[k])
    FPR_Values[k] = false_positive[k] / (false_positive[k] + true_negative[k])

auc_value = auc(FPR_Values, TPR_Values)
print('Area Under The ROC Curve =', auc_value)

fig_7, ax = plt.subplots(figsize = [12.8, 7.2], dpi = 100)
plt.title('Detection of Exon region of Gene NG_032650 Using SSA + WOA', fontsize=15, pad=12)
plt.ylabel('Normalised Period-3 Power spectrum', fontsize=12, labelpad=5)
plt.xlabel('Relative Base location (bp)', fontsize = 12, labelpad = 5)
plt.plot(np.full(8000, 0.2), alpha = 0.5, linewidth = 0.5, color='r')
plt.plot(predicted_exons, linewidth=1, color='b')
plt.plot(actual_exons, color='g')

sequence_id = "X01913"
region_values = [423, 562, 689, 911, 1754, 1879]

sequence = sequence_download(sequence_id)

coding_regions = region_values
non_coding_regions = [0] + coding_regions + [len(sequence) + 1]
coding_regions, non_coding_regions = cds_calculation(coding_regions), non_cds_calculation(non_coding_regions)

actual_exons = np.zeros(len(sequence))
for i in coding_regions:
    actual_exons[i] = 1

mapped_A, mapped_T, mapped_C, mapped_G = voss_mapping(sequence)
predicted_exons = exons_predictions(Filter_weights, mapped_A, mapped_T, mapped_C, mapped_G)

true_positive, false_negative, false_positive, true_negative = binary_classification(coding_regions, non_coding_regions, predicted_exons, sequence)
TP, FN, FP, TN = true_positive[20], false_negative[20], false_positive[20], true_negative[20]

TPR, TNR, PPV, ACC = TP / (TP + FN), TN / (FP + TN), TP / (TP + FP), (TP + TN) / (TP + FP + TN + FN)
MCC = (TP * TN - FN * FP) / (((TP + FN) * (TN + FP) * (TP + FP) * (TN + FN)) ** (1/2))
ACP = (TP / (TP + FN) + TP / (TP + FP) + TN / (TN + FP) + TN / (TN + FN)) / 4
AC = (ACP - 0.5) * 2

exon_energy, intron_energy = [], []
for i in coding_regions:
    exon_energy.append(predicted_exons[i])
for i in non_coding_regions:
    intron_energy.append(predicted_exons[i])

SNR1, SNR2 = sum(exon_energy)/sum(intron_energy), max(predicted_exons) / mean(predicted_exons)

print('SNR1 =', SNR1)
print('SNR2 =', SNR2)
print("Approximate Correlation =", AC)
print('Accuracy of Exon Classification =', ACC)
print('True Positive Rate (Sensitiviy) =', TPR)
print('True Negative Rate (Specificity) =', TNR)
print('Matthews Correlation Coefficient = ', MCC), 
print('Positive Predictive Value (Precision) =',PPV)

TPR_Values, FPR_Values = np.zeros(101), np.zeros(101)

for k in range(101):
    TPR_Values[k] = true_positive[k] / (true_positive[k] + false_negative[k])
    FPR_Values[k] = false_positive[k] / (false_positive[k] + true_negative[k])

auc_value = auc(FPR_Values, TPR_Values)
print('Area Under The ROC Curve =', auc_value)

fig_8, ax = plt.subplots(figsize = [12.8, 7.2], dpi = 100)
plt.title('Detection of Exon region of Gene NG_041776 Using SSA + WOA', fontsize=15, pad=12)
plt.ylabel('Normalised Period-3 Power spectrum', fontsize=12, labelpad=5)
plt.xlabel('Relative Base location (bp)', fontsize = 12, labelpad = 5)
plt.plot(np.full(8000, 0.2), alpha = 0.5, linewidth = 0.5, color='r')
plt.plot(predicted_exons, linewidth=1, color='b')
plt.plot(actual_exons, color='g')

sequence_id = "L25354"
region_values = [1, 236, 365, 587, 1535, 1834]

sequence = sequence_download(sequence_id)

coding_regions = region_values
non_coding_regions = [0] + coding_regions + [len(sequence) + 1]
coding_regions, non_coding_regions = cds_calculation(coding_regions), non_cds_calculation(non_coding_regions)

actual_exons = np.zeros(len(sequence))
for i in coding_regions:
    actual_exons[i] = 1

mapped_A, mapped_T, mapped_C, mapped_G = voss_mapping(sequence)
predicted_exons = exons_predictions(Filter_weights, mapped_A, mapped_T, mapped_C, mapped_G)

true_positive, false_negative, false_positive, true_negative = binary_classification(coding_regions, non_coding_regions, predicted_exons, sequence)
TP, FN, FP, TN = true_positive[20], false_negative[20], false_positive[20], true_negative[20]

TPR, TNR, PPV, ACC = TP / (TP + FN), TN / (FP + TN), TP / (TP + FP), (TP + TN) / (TP + FP + TN + FN)
MCC = (TP * TN - FN * FP) / (((TP + FN) * (TN + FP) * (TP + FP) * (TN + FN)) ** (1/2))
ACP = (TP / (TP + FN) + TP / (TP + FP) + TN / (TN + FP) + TN / (TN + FN)) / 4
AC = (ACP - 0.5) * 2

exon_energy, intron_energy = [], []
for i in coding_regions:
    exon_energy.append(predicted_exons[i])
for i in non_coding_regions:
    intron_energy.append(predicted_exons[i])

SNR1, SNR2 = sum(exon_energy)/sum(intron_energy), max(predicted_exons) / mean(predicted_exons)

print('SNR1 =', SNR1)
print('SNR2 =', SNR2)
print("Approximate Correlation =", AC)
print('Accuracy of Exon Classification =', ACC)
print('True Positive Rate (Sensitiviy) =', TPR)
print('True Negative Rate (Specificity) =', TNR)
print('Matthews Correlation Coefficient = ', MCC), 
print('Positive Predictive Value (Precision) =',PPV)

TPR_Values, FPR_Values = np.zeros(101), np.zeros(101)

for k in range(101):
    TPR_Values[k] = true_positive[k] / (true_positive[k] + false_negative[k])
    FPR_Values[k] = false_positive[k] / (false_positive[k] + true_negative[k])

auc_value = auc(FPR_Values, TPR_Values)
print('Area Under The ROC Curve =', auc_value)

fig_9, ax = plt.subplots(figsize = [12.8, 7.2], dpi = 100)
plt.title('Detection of Exon region of Gene NG_008257 Using SSA + WOA', fontsize=15, pad=12)
plt.ylabel('Normalised Period-3 Power spectrum', fontsize=12, labelpad=5)
plt.xlabel('Relative Base location (bp)', fontsize = 12, labelpad = 5)
plt.plot(np.full(8000, 0.2), alpha = 0.5, linewidth = 0.5, color='r')
plt.plot(predicted_exons, linewidth=1, color='b')
plt.plot(actual_exons, color='g')

sequence_id = "AF059180"
region_values = [27, 118, 249, 426]

sequence = sequence_download(sequence_id)

coding_regions = region_values
non_coding_regions = [0] + coding_regions + [len(sequence) + 1]
coding_regions, non_coding_regions = cds_calculation(coding_regions), non_cds_calculation(non_coding_regions)

actual_exons = np.zeros(len(sequence))
for i in coding_regions:
    actual_exons[i] = 1

mapped_A, mapped_T, mapped_C, mapped_G = voss_mapping(sequence)
predicted_exons = exons_predictions(Filter_weights, mapped_A, mapped_T, mapped_C, mapped_G)

true_positive, false_negative, false_positive, true_negative = binary_classification(coding_regions, non_coding_regions, predicted_exons, sequence)
TP, FN, FP, TN = true_positive[20], false_negative[20], false_positive[20], true_negative[20]

TPR, TNR, PPV, ACC = TP / (TP + FN), TN / (FP + TN), TP / (TP + FP), (TP + TN) / (TP + FP + TN + FN)
MCC = (TP * TN - FN * FP) / (((TP + FN) * (TN + FP) * (TP + FP) * (TN + FN)) ** (1/2))
ACP = (TP / (TP + FN) + TP / (TP + FP) + TN / (TN + FP) + TN / (TN + FN)) / 4
AC = (ACP - 0.5) * 2

exon_energy, intron_energy = [], []
for i in coding_regions:
    exon_energy.append(predicted_exons[i])
for i in non_coding_regions:
    intron_energy.append(predicted_exons[i])

SNR1, SNR2 = sum(exon_energy)/sum(intron_energy), max(predicted_exons) / mean(predicted_exons)

print('SNR1 =', SNR1)
print('SNR2 =', SNR2)
print("Approximate Correlation =", AC)
print('Accuracy of Exon Classification =', ACC)
print('True Positive Rate (Sensitiviy) =', TPR)
print('True Negative Rate (Specificity) =', TNR)
print('Matthews Correlation Coefficient = ', MCC), 
print('Positive Predictive Value (Precision) =',PPV)

TPR_Values, FPR_Values = np.zeros(101), np.zeros(101)

for k in range(101):
    TPR_Values[k] = true_positive[k] / (true_positive[k] + false_negative[k])
    FPR_Values[k] = false_positive[k] / (false_positive[k] + true_negative[k])

auc_value = auc(FPR_Values, TPR_Values)
print('Area Under The ROC Curve =', auc_value)

fig_10, ax = plt.subplots(figsize = [12.8, 7.2], dpi = 100)
plt.title('Detection of Exon region of Gene NG_017044 Using SSA + WOA', fontsize=15, pad=12)
plt.ylabel('Normalised Period-3 Power spectrum', fontsize=12, labelpad=5)
plt.xlabel('Relative Base location (bp)', fontsize = 12, labelpad = 5)
plt.plot(np.full(8000, 0.2), alpha = 0.5, linewidth = 0.5, color='r')
plt.plot(predicted_exons, linewidth=1, color='b')
plt.plot(actual_exons, color='g')

sequence_id = "D16497"
region_values = [132, 335, 530, 752, 1196, 1436]

sequence = sequence_download(sequence_id)

coding_regions = region_values
non_coding_regions = [0] + coding_regions + [len(sequence) + 1]
coding_regions, non_coding_regions = cds_calculation(coding_regions), non_cds_calculation(non_coding_regions)

actual_exons = np.zeros(len(sequence))
for i in coding_regions:
    actual_exons[i] = 1

mapped_A, mapped_T, mapped_C, mapped_G = voss_mapping(sequence)
predicted_exons = exons_predictions(Filter_weights, mapped_A, mapped_T, mapped_C, mapped_G)

true_positive, false_negative, false_positive, true_negative = binary_classification(coding_regions, non_coding_regions, predicted_exons, sequence)
TP, FN, FP, TN = true_positive[20], false_negative[20], false_positive[20], true_negative[20]

TPR, TNR, PPV, ACC = TP / (TP + FN), TN / (FP + TN), TP / (TP + FP), (TP + TN) / (TP + FP + TN + FN)
MCC = (TP * TN - FN * FP) / (((TP + FN) * (TN + FP) * (TP + FP) * (TN + FN)) ** (1/2))
ACP = (TP / (TP + FN) + TP / (TP + FP) + TN / (TN + FP) + TN / (TN + FN)) / 4
AC = (ACP - 0.5) * 2

exon_energy, intron_energy = [], []
for i in coding_regions:
    exon_energy.append(predicted_exons[i])
for i in non_coding_regions:
    intron_energy.append(predicted_exons[i])

SNR1, SNR2 = sum(exon_energy)/sum(intron_energy), max(predicted_exons) / mean(predicted_exons)

print('SNR1 =', SNR1)
print('SNR2 =', SNR2)
print("Approximate Correlation =", AC)
print('Accuracy of Exon Classification =', ACC)
print('True Positive Rate (Sensitiviy) =', TPR)
print('True Negative Rate (Specificity) =', TNR)
print('Matthews Correlation Coefficient = ', MCC), 
print('Positive Predictive Value (Precision) =',PPV)

TPR_Values, FPR_Values = np.zeros(101), np.zeros(101)

for k in range(101):
    TPR_Values[k] = true_positive[k] / (true_positive[k] + false_negative[k])
    FPR_Values[k] = false_positive[k] / (false_positive[k] + true_negative[k])

auc_value = auc(FPR_Values, TPR_Values)
print('Area Under The ROC Curve =', auc_value)

fig_11, ax = plt.subplots(figsize = [12.8, 7.2], dpi = 100)
plt.title('Detection of Exon region of Gene NG_023371 Using SSA + WOA', fontsize=15, pad=12)
plt.ylabel('Normalised Period-3 Power spectrum', fontsize=12, labelpad=5)
plt.xlabel('Relative Base location (bp)', fontsize = 12, labelpad = 5)
plt.plot(np.full(8000, 0.2), alpha = 0.5, linewidth = 0.5, color='r')
plt.plot(predicted_exons, linewidth=1, color='b')
plt.plot(actual_exons, color='g')

sequence_id = "NG_029637"
region_values = [32240, 32696, 35985, 37394, 38786, 39049, 40451, 40566, 
                 41330, 41486, 45046, 45315, 46683, 46868, 47137, 47226, 
                 49392, 49655, 58339, 58611, 59190, 59462, 60069, 60341, 
                 63256, 63528, 65833, 66105, 74726, 74998, 76576, 76848, 
                 80917, 81039, 82174, 82317, 84878, 84997, 87017, 87160, 
                 87924, 88054, 91573, 91705, 92853, 93004, 93802, 93898, 
                 96563, 96724, 99122, 99285, 101991, 102101]

sequence = sequence_download(sequence_id)

coding_regions = region_values
non_coding_regions = [0] + coding_regions + [len(sequence) + 1]
coding_regions, non_coding_regions = cds_calculation(coding_regions), non_cds_calculation(non_coding_regions)

actual_exons = np.zeros(len(sequence))
for i in coding_regions:
    actual_exons[i] = 1

mapped_A, mapped_T, mapped_C, mapped_G = voss_mapping(sequence)
predicted_exons = exons_predictions(Filter_weights, mapped_A, mapped_T, mapped_C, mapped_G)

true_positive, false_negative, false_positive, true_negative = binary_classification(coding_regions, non_coding_regions, predicted_exons, sequence)
TP, FN, FP, TN = true_positive[20], false_negative[20], false_positive[20], true_negative[20]

TPR, TNR, PPV, ACC = TP / (TP + FN), TN / (FP + TN), TP / (TP + FP), (TP + TN) / (TP + FP + TN + FN)
MCC = (TP * TN - FN * FP) / (((TP + FN) * (TN + FP) * (TP + FP) * (TN + FN)) ** (1/2))
ACP = (TP / (TP + FN) + TP / (TP + FP) + TN / (TN + FP) + TN / (TN + FN)) / 4
AC = (ACP - 0.5) * 2

exon_energy, intron_energy = [], []
for i in coding_regions:
    exon_energy.append(predicted_exons[i])
for i in non_coding_regions:
    intron_energy.append(predicted_exons[i])

SNR1, SNR2 = sum(exon_energy)/sum(intron_energy), max(predicted_exons) / mean(predicted_exons)

print('SNR1 =', SNR1)
print('SNR2 =', SNR2)
print("Approximate Correlation =", AC)
print('Accuracy of Exon Classification =', ACC)
print('True Positive Rate (Sensitiviy) =', TPR)
print('True Negative Rate (Specificity) =', TNR)
print('Matthews Correlation Coefficient = ', MCC), 
print('Positive Predictive Value (Precision) =',PPV)

TPR_Values, FPR_Values = np.zeros(101), np.zeros(101)

for k in range(101):
    TPR_Values[k] = true_positive[k] / (true_positive[k] + false_negative[k])
    FPR_Values[k] = false_positive[k] / (false_positive[k] + true_negative[k])

auc_value = auc(FPR_Values, TPR_Values)
print('Area Under The ROC Curve =', auc_value)

fig_12, ax = plt.subplots(figsize = [12.8, 7.2], dpi = 100)
plt.title('Detection of Exon region of Gene NG_029637 Using SSA + WOA', fontsize=15, pad=12)
plt.ylabel('Normalised Period-3 Power spectrum', fontsize=12, labelpad=5)
plt.xlabel('Relative Base location (bp)', fontsize = 12, labelpad = 5)
plt.plot(np.full(8000, 0.2), alpha = 0.5, linewidth = 0.5, color='r')
plt.plot(predicted_exons, linewidth=1, color='b')
plt.plot(actual_exons, color='g')